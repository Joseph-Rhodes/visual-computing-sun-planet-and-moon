<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from "https://web.cs.manchester.ac.uk/three/three.js-master/build/three.module.js";
        import { OrbitControls } from "https://web.cs.manchester.ac.uk/three/three.js-master/examples/jsm/controls/OrbitControls.js";

        let curve; // Define curve globally

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(0,30,500);

            const renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const pointLight = new THREE.PointLight(0Xffffff);
            scene.add(pointLight);

            const ambLight = new THREE.AmbientLight(0X222222);
            scene.add(ambLight);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Texture Loader
            const loader = new THREE.TextureLoader();

            // Milky Way
            const milkywayGeometry = new THREE.SphereGeometry(1000, 100, 100);
            const milkywayMaterial = new THREE.MeshStandardMaterial({
                map: loader.load("/Images/milkyway.jpeg"),
                side: THREE.DoubleSide,
            });
            const milkywayMesh = new THREE.Mesh(milkywayGeometry, milkywayMaterial);
            scene.add(milkywayMesh);

            // Sun
            const sunGeometry = new THREE.SphereGeometry(109, 400, 200);
            const sunMaterial = new THREE.MeshStandardMaterial({
                emissive: 0xffd700,
                emissiveMap: loader.load("/Images/Sun.jpeg"),
                emissiveIntensity: 1,
                wireframe: false
            });    
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sunMesh);

            // Earth System
            const earthSystem = new THREE.Group();

            // Earth
            const earthGeometry = new THREE.SphereGeometry(25, 50, 50);
            const earthMaterial = new THREE.MeshPhongMaterial({
                map: loader.load("/Images/Earth.jpeg"),
            });
            const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            earthMesh.rotation.z = 0.41;
            earthSystem.add(earthMesh);

            // Moon
            const moonGeometry = new THREE.SphereGeometry(5, 40, 20);
            const moonMaterial = new THREE.MeshPhongMaterial({
                map: loader.load("/Images/Moon.jpeg"),
            });
            const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            moonMesh.position.set(50, 0, 0);
            earthSystem.add(moonMesh);

            // Earth Axis
            const axisPoints = [new THREE.Vector3(0,35,0), new THREE.Vector3(0,-35,0)];

            const axisGeomtery = new THREE.BufferGeometry().setFromPoints(axisPoints);
            const axis = new THREE.Line(
                axisGeomtery,
                new THREE.LineBasicMaterial({color: 0x330000, transparent: true, opacity: 0.5})
            );

            axis.rotation.z = 0.41;
            earthSystem.add(axis);

            // Clouds
            const cloudGeometry = new THREE.SphereGeometry(26, 50, 50);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                map: loader.load("/Images/clouds.jpeg"),
                transparent: true,
                opacity: 1,
            });
            const cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloudMesh.rotation.z = 0.41;
            earthSystem.add(cloudMesh);

            // Adding the earth system
            scene.add(earthSystem);

            // Shadows
            renderer.shadowMap.enabled = true;
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 512;
            pointLight.shadow.mapSize.height = 512;
            pointLight.shadow.camera.near = 150;
            pointLight.shadow.camera.far = 350;
            earthMesh.castShadow = true;
            earthMesh.receiveShadow = true;
            cloudMesh.receiveShadow = true;
            moonMesh.castShadow = true;
            moonMesh.receiveShadow = true;

            // Ellipse Curve
            curve = new THREE.EllipseCurve(
                0,  0,            // ax, aY
                250, 300,           // xRadius, yRadius
                0,  2 * Math.PI,  // aStartAngle, aEndAngle
                false,            // aClockwise
                0                 // aRotation
            );

            const points = curve.getPoints(200);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
            const ellipse = new THREE.Line(geometry, material);
            ellipse.rotateX(-Math.PI/2);
            scene.add(ellipse);
    

        const orbitTime = 1;
        const moonOrbitRadius = 55;
        const moonOrbitSpeed = 80;

        function animate(){
            const time = 0.00001 * performance.now();
            const t = (time % orbitTime) / orbitTime;

            const p = curve.getPoint(t); // Use curve here
            console.log(p, t);

            earthMesh.position.x = p.x;
            earthMesh.position.z = p.y;

            moonMesh.position.x = -Math.cos(time * moonOrbitSpeed) * moonOrbitRadius;
            moonMesh.position.z = -Math.sin(time * moonOrbitSpeed) * moonOrbitRadius; // Correct y position

            sunMesh.rotation.y += 0.0008;
            earthMesh.rotation.y += 0.0015;
            cloudMesh.rotation.y += 0.0025;
            moonMesh.rotation.y += 0.0001;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
